---
title: Programando en el Tidyverse
author: Johan Rosa
date: '2021-04-05'
slug: programando-en-el-tidyverse
categories:
  - tutorial
tags:
  - tidyverse
  - dplyr
  - shiny
subtitle: ''
description: 'Un post que instruye sobre cómo aprovechar el data masking del tidyverse para programar funciones propias en R'
image: 'img/banner/hadley-wickham.jpg'
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>Cuando me topé por primera vez con las funciones del <code>tidyverse</code>, específicamente con el paquete <code>dplyr</code>, lo que más me atrajo fue la posibilidad de usar en las funciones las variables in-data como si fueran objetos del ambiente global (<em>data masking</em>).</p>
<p>Es como utilizar en un data frame el poco recomendado <code>attach()</code>, pero sin el downside que deriva este en distintos escenarios.</p>
<p>Un ejemplo:</p>
<pre class="r"><code>mtcars[mtcars$cyl == 8 &amp; mtcars$am == 1,]</code></pre>
<pre><code>##                 mpg cyl disp  hp drat   wt qsec vs am gear carb
## Ford Pantera L 15.8   8  351 264 4.22 3.17 14.5  0  1    5    4
## Maserati Bora  15.0   8  301 335 3.54 3.57 14.6  0  1    5    8</code></pre>
<pre class="r"><code>filter(mtcars, cyl == 8, am == 1)</code></pre>
<pre><code>##                 mpg cyl disp  hp drat   wt qsec vs am gear carb
## Ford Pantera L 15.8   8  351 264 4.22 3.17 14.5  0  1    5    4
## Maserati Bora  15.0   8  301 335 3.54 3.57 14.6  0  1    5    8</code></pre>
<pre class="r"><code># Opción que muchos nuevos usuarios intentan, por parecer intuitivo
# pero que sin excepciones conduce a un error

# mtcars[cyl == 8, am == 1]</code></pre>
<p>En el primer ejemplo hubo que escribir el nombre del set de datos 3 veces, mientras que con la función <code>dplyr::filter()</code> solo una vez.</p>
<p>Esto se logra gracias al <em>data masking</em> que usan las funciones del tidyverse, el cual es muy conveniente, sobre todo en niveles iniciales, porque evita algunas confusiones y permite hacer ciertas tareas con menos código.</p>
<p>Ahora bien, en la medida que uno va avanzando se encuentra con el amargo sabor de que lo que nos facilitaba la vida del tidyverse se convierte en una dificultad a la hora de programar con él.</p>
<p>Recuerdo hace unos años cuando intenté hacer mis primeras funciones que involucraban el tidyverse. En ese entonces los verbos paralelos del paquete no habían sido abandonados, aún se recomendaba el uso de <code>mutate_()</code>, <code>mutate_at()</code>, <code>group_by_()</code>, <code>group_by_at()</code>, <code>summarise_at()</code> y unas tantas otras (En las versiones más recientes se han integrado otras funciones que evitan la necesidad recurrir a todas estas funciones gemelas del tidyverse, no es necesario que se preocupen por aprender a usarlas).</p>
<p>Teniendo en cuesta esto, esta vez pretendo hacer una breve explicación de como crear funciones que aprovechen el <em>data masking</em> del tidyvers y que aplanen el camino para aquellos que pretenden crear paquetes con <code>{dplyr}</code>, <code>{ggplot2}</code> y otros como dependencias. También para aquellos que van a utilizar shiny y necesitarán crear funciones que reciban el nombre de las variables en forma de <code>strings</code> como argumento (los imputs de shiny normalmente devuelven valores de este tipo).</p>
<p>En fin, para que no intenten hacer esto:</p>
<pre class="r"><code>error1 &lt;- function(variable = cyl) {
  mtcars %&gt;% 
    group_by(variable) %&gt;% 
    summarise(mean_mpg = mean(mpg))
}

error2 &lt;- function(variable = &#39;cyl&#39;) {
  mtcars %&gt;% 
    group_by(variable) %&gt;% 
    summarise(mean_mpg = mean(mpg))
}</code></pre>
<div id="variables-de-ambiente-variables-en-data-y-data-masking" class="section level2">
<h2>Variables de ambiente, variables en data y <em>data masking</em></h2>
<p>La idea principal del <em>data masking</em> es estrechar la brecha entre las dos vertientes de variables que pueden existir en R. Por un lado las variables de ambiente y por otro las variables en data.</p>
<p>Las variables de ambiente son esos objetos que residen en el ambiente global de nuestra sesión de trabajo y que normalmente son creados usando el operador de asignación <code>&lt;-</code>.</p>
<p>Las variables en data son aquellas variables que residen dentro de un objeto del ambiente global, como un data frame (U otros tipos de lista) y a ellas se accede usando operadores como <code>$</code> y la notación de corchetes <code>[</code> o <code>[[</code>.</p>
<p>Para poner un ejemplo, el siguiente fragmento de código crea una variable de ambiente que contiene a su vez dos variables en data.</p>
<pre class="r"><code>personas &lt;- data.frame(
  nombre = c(&quot;Johan&quot;, &quot;Fulano&quot;),
  ead = c(28, 32)
)

personas$nombre</code></pre>
<pre><code>## [1] &quot;Johan&quot;  &quot;Fulano&quot;</code></pre>
<p>El objeto <code>personas</code> es una variable de ambiente, reside en el ambiente global, mientras que <code>nombre</code> y <code>edad</code> son variables en data, contenidas en personas. Cuando se usan las funciones con <em>data masking</em> se disuelve un poco la diferencia entre estos objetos, pero en general es importante tenerlo en cuenta antes de ir un paso más lejos en la programación en R.</p>
</div>
<div id="usando-el-embracing-variable-y-el-pronombre-.data-variable" class="section level2">
<h2>Usando el <em>embracing</em> <code>{{ variable }}</code> y el pronombre <code>.data[[ "variable" ]]</code></h2>
<p>El <em>embracing</em> es la primera alternativa que nos provee el tidyverse para programar usando funciones que utilizan <em>data masking</em>. Con esto se abre la posibilidad de generar referencias indirectas en las funciones.</p>
<p>La primera demostración consiste en crear una función que recibiendo un data frame y el nombre de las variables a mapear en cada eje, cree un scatter plot.</p>
<p>En este caso hay que prestar atención a la forma que se usan los argumentos en el cuerpo de la función, siempre se encierran entre un par de llaves <code>{{ argumento }}</code> y así se pasa el nombre de las variables en data como si fueran variables de ambiente en nuestras funciones.</p>
<pre class="r"><code>scatter_plot &lt;- function(data, x, y, color = NULL) {
  
  ggplot2::ggplot(data = data, ggplot2::aes(x = {{ x }}, y = {{ y }}, color = {{ color }})) +
    ggplot2::geom_point() +
    ggplot2::theme_minimal() +
    ggplot2::theme(legend.position = &quot;bottom&quot;)
}


# Ya tenemos una función que usa data masking
scatter_plot(mtcars, x = wt, y = mpg, color = am)</code></pre>
<p><img src="/post/2021-04-05-programando-en-el-tidyverser_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code>scatter_plot(data = iris, x = Sepal.Width, y = Sepal.Length, color = Species)</code></pre>
<p><img src="/post/2021-04-05-programando-en-el-tidyverser_files/figure-html/unnamed-chunk-4-2.png" width="672" /></p>
<p>Otro recurso a nuestra disposición cuando se desea pasar strings con los nombres de las variables es el pronombre <code>.data[[]]</code>.</p>
<p>Para usar esta alternativa creemos una función que devuelva el promedio de la variables que se le indique.</p>
<pre class="r"><code>calc_media &lt;- function(data, variable) {
  
    dplyr::summarise(data, promedio = mean(.data[[variable]]))
}

calc_media(mtcars, variable = &quot;mpg&quot;)</code></pre>
<pre><code>##   promedio
## 1 20.09062</code></pre>
<p>Esto no solo funciona en el scope de las funciones, en el ambiente global se podría utilizar también. Consideren el siguiente ejemplo de un loop:</p>
<pre class="r"><code>for (variable in c(&quot;mpg&quot;, &quot;wt&quot;, &quot;hp&quot;)) {
  dplyr::summarise(mtcars, media = mean(.data[[variable]])) %&gt;% print()
}</code></pre>
</div>
<div id="programando-con-tidy-selection" class="section level2">
<h2>Programando con <code>tidy selection</code></h2>
<p>Algo muy distinto al <em>data masking</em> pero igual de útil es el <em>tidy selection</em>, que es una herramienta complementaria del tidyverse que facilita trabajar con más de una variable de manera simultánea.</p>
<p>Es probable que en este punto ya hayan utilizado las funciones <code>starts_with()</code>, <code>ends_with()</code>, <code>where()</code>, <code>everything()</code> dentro de la función <code>select()</code> o en la recién introducida <code>across()</code>.</p>
<pre class="r"><code># Selecciona las variables que inician con &#39;sepal&#39;
select(iris, starts_with(&quot;sepal&quot;)) %&gt;% 
  head(3)

# revuelve el promedio de las variables que inician con &quot;petal&quot;
dplyr::summarise(iris, across(starts_with(&#39;petal&#39;), mean))</code></pre>
<p>El punto es que estas funciones de asistencia del tidyselect se pueden aprovechar en nuestras funciones, abriendo un mundo de posibilidades para el usuario.</p>
<p>A continuación un ejemplo simple pero poderoso, una función que recibe sentencias de <em>tidy selection</em> como argumento y funciones para resumir dichas columnas. Para esto se hace uso de la función <code>all_of()</code>.</p>
<pre class="r"><code>my_summary &lt;- function(data, cols = NULL, fun = mean) {
  dplyr::summarise(
    data, 
    dplyr::across(
      .cols = all_of(cols),
      .fns = fun
    )
  )
}</code></pre>
<p>A continuación ponemos a prueba la función, demostando su flexibilidad y conveniencia.</p>
<pre class="r"><code>my_summary(iris, cols = starts_with(&quot;petal&quot;), fun = sd)</code></pre>
<pre><code>##   Petal.Length Petal.Width
## 1     1.765298   0.7622377</code></pre>
<pre class="r"><code>my_summary(mtcars, cols = c(&quot;mpg&quot;, &quot;wt&quot;), fun = median)</code></pre>
<pre><code>##    mpg    wt
## 1 19.2 3.325</code></pre>
</div>
<div id="usando-lo-aprendido-para-crear-una-aplicación-en-shiny" class="section level2">
<h2>Usando lo aprendido para crear una aplicación en shiny</h2>
<p>Normalmente los inputs en las aplicaciones creadas con shiny general objetos que contienen números y caracteres para ser utilizados en el servidor y controlar los objetos reactivos de nuestra aplicación.</p>
<p>En este ejemple crearemos un shinyApp que permita construir un gráfico de dispersión con las variables del set de datos <code>mtcars</code>. La idea es que el usuario controle las variable que serán mapeadas a los ejes y al color de los puntos.</p>
<p>El primer paso es ajustar un poco la función para crear gráficos de dispersión que creamos anteriormente, para que en lugar de funiconar con <em>data masking</em>, reciba strings con los nombres de las variables.</p>
<pre class="r"><code>shiny_scatter_plot &lt;- function(data, x, y, color = NULL) {
  
  ggplot2::ggplot(
    data = data, 
    ggplot2::aes(x = .data[[x]], y = .data[[y]], color = as.factor(.data[[color]]))) +
    ggplot2::geom_point() +
    ggplot2::theme_minimal() +
    ggplot2::theme(legend.position = &quot;bottom&quot;) +
    labs(color = color)
}</code></pre>
<p>Con esto se puede entonces crear la aplicación. No entraremos en detalles de cada componente en esta ocasión, pero queda el compromiso implicito de hacer un post sobre este tema. Esta vez la intención es mostrar una aplicación rápida de lo explicado.</p>
<pre class="r"><code>library(shiny)
library(dplyr)
library(ggplot2)

ui &lt;- fluidPage(
  # Un título
  h1(&quot;Explorando la base mtcars&quot;),
  # Layout del app
  sidebarLayout(
    sidebarPanel = sidebarPanel(
      # Inputs para seleccionar variables de cada eje
      selectInput(inputId = &quot;x&quot;, label = &quot;Variable del eje X&quot;,
                  choices = c(&quot;mpg&quot;, &quot;disp&quot;, &quot;hp&quot;, &quot;draft&quot;, &quot;qsec&quot;, &quot;wt&quot;), 
                  selected = &quot;wt&quot;,
                  multiple = FALSE),
      
      selectInput(inputId = &quot;y&quot;, label = &quot;Variable del eje Y&quot;,
                  choices = c(&quot;mpg&quot;, &quot;disp&quot;, &quot;hp&quot;, &quot;draft&quot;, &quot;qsec&quot;, &quot;wt&quot;), 
                  selected = &quot;mpg&quot;,
                  multiple = FALSE),
      
      selectInput(inputId = &quot;color&quot;, label = &quot;Variable color&quot;,
                  choices = c(&quot;cyl&quot;, &quot;am&quot;, &quot;vs&quot;, &quot;gear&quot;, &quot;carb&quot;),
                  selected = &quot;cyl&quot;, multiple = FALSE)
      
    ),
    mainPanel = mainPanel(
      # Output a mostra
      h2(textOutput(&quot;title&quot;)),
      plotOutput(&quot;plot&quot;)
    )
  )
)

server &lt;- function(input, output, session) {
  
  # El título del gráfico
  output$title &lt;- renderText(paste(&quot;mtcars:&quot;, input$x, &quot;Vs&quot;, input$y))
  # Usando los inputs para generar el gráfico
  output$plot &lt;- renderPlot({
    # Usando nuestra función
    shiny_scatter_plot(mtcars, x = input$x, y = input$y, color = input$color)
    })
  
}

shinyApp(ui, server)</code></pre>
<p><img src="/post/2021-04-05-programando-en-el-tidyverser_files/programming_tidyverse_shinyapp.gif" /></p>
</div>
<div id="consideraciones-finales" class="section level2">
<h2>Consideraciones finales</h2>
<p>No es lo mismo ser un usuario de R que un programador en R. Es importante comprender muy bien la estructura del leguaje y los objetos para ser programador, hay que dominar las clases, métodos, expreciones y muchos conceptos abstractos pero al final de cuentas vale la pena.</p>
<p>Yo empecé este trayecto con el libro de <a href="https://adv-r.hadley.nz/index.html">R avanzado</a> de Hadley Wickhan, que da un paseo bastante detallado desde los aspectos más básicos como los atributos de los distintos tipos de objetos, hasta el <em>metaprogramming</em>.</p>
<p>Una vez avanzado este libro es importante empezar a leer <a href="https://r-pkgs.org/">R packages</a>, y así aplicar lo aprendido en el desarrollo de paquetes propios.</p>
</div>
<div id="referencias" class="section level2">
<h2>Referencias</h2>
<ul>
<li><a href="https://dplyr.tidyverse.org/articles/programming.html">Programming with dplyr</a></li>
<li><a href="https://adv-r.hadley.nz/functions.html#lazy-evaluation">Advance R, 6.5 Lazy evaluation</a></li>
<li><a href="https://tidyeval.tidyverse.org/sec-why-how.html">Tidy evaluation, capitulo 2.1</a></li>
</ul>
</div>
